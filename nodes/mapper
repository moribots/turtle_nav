#!/usr/bin/env python
"""
DESCRIPTION:


SUBSCRIBERS:

SERVICES:

REFERENCE: https://hotblackrobotics.github.io/en/blog/2018/01/29/seq-goals-py/
"""

from __future__ import division
import rospy
import numpy as np
from random import randrange
import actionlib
from actionlib_msgs.msg import GoalStatus
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from nav_msgs.msg import OccupancyGrid
# from sensor_msgs.msg import LaserScan


class AutoMap():
    def __init__(self):

        rospy.init_node('mapper', anonymous=True)
        # counter to init next 2D nav goal
        self.completion = 0
        # Initialise goal pose variables
        self.x = 0
        self.y = 0
        # Create action client
        self.client = actionlib.SimpleActionClient('move_base', MoveBaseAction)
        rospy.loginfo("Waiting for move_base action server...")
        wait = self.client.wait_for_server(rospy.Duration(5.0))
        if not wait:
            rospy.logerr("Action server not available!")
            rospy.signal_shutdown("Action server not available!")
            return
        rospy.loginfo("Connected to move base server")
        # callback from /map topic
        self.sub = rospy.Subscriber('/map', OccupancyGrid, self.callback_map)

    def callback_map(self, map_data):
        """ DESCRIPTION

            Args:
        """
        try:
            self.automap(map_data)
            # log input data as debug-level message
            # rospy.logdebug(map)
        except rospy.ROSInterruptException:
            pass

    def automap(self, map_data):
        """ DESCRIPTION

            Args:
        """
        valid = False

        while valid is False:
            # randomly select cell in map
            index = randrange(len(map_data.data))
            check = map_data.data[index]
            # check that cell is not unknown or blocked
            if check != -1 and check <= 0.196:
                valid = True
        # index is in row-major order, convert to row,col
        # 384 is the number of columns
        numcol = 384
        row = index / numcol
        col = index % numcol

        # State resolution from map.yaml
        resolution = 0.05
        # we know each cell maps to resolution [m]
        # we know the origin is -10,-10 (Left Bottom of map)
        origin_x = -10
        origin_y = -10
        self.x = origin_x + col * resolution
        self.y = origin_y + row * resolution

        coord = [self.x, self.y]
        # log chosen coord
        rospy.loginfo(coord)

        # If completion counter is even, set 2D nav goal
        if self.completion % 2 == 0:
            # make completion counter odd
            # will become even when goal is reached
            self.completion += 1
            self.movebase_client()

    def done_cb(self, status, result):
        """DESCRIPTION

            Args:

            Returns:
        """
        self.completion += 1
        # Reference for terminal status values: http://docs.ros.org/diamondback/api/actionlib_msgs/html/msg/GoalStatus.html
        if status == 2:
            rospy.loginfo(
                "Goal pose " + str(self.goal_cnt) +
                " received a cancel request after it started executing, completed execution!"
            )

        if status == 3:
            rospy.loginfo("Goal pose " + str(self.goal_cnt) + " reached")

        if status == 4:
            rospy.loginfo("Goal was aborted by the Action Server")
            rospy.signal_shutdown("Goal aborted, shutting down!")
            return

        if status == 5:
            rospy.loginfo("Goal has been rejected by the Action Server")
            rospy.signal_shutdown("Goal rejected, shutting down!")
            return

        if status == 8:
            rospy.loginfo(
                "Goal received a cancel request before it started executing, successfully cancelled!"
            )

    def movebase_client(self):
        """DESCRIPTION

            Args:

            Returns:
        """
        goal = MoveBaseGoal()
        goal.target_pose.header.frame_id = "map"
        goal.target_pose.header.stamp = rospy.Time.now()
        goal.target_pose.pose.position.x = self.x
        goal.target_pose.pose.position.y = self.y
        rospy.loginfo("Sending goal pose to Action Server")
        self.client.send_goal(goal, self.done_cb)


class Mapper():
    """ DESCRIPTION
    """
    def __init__(self):
        self.completion = 0
        self.sub = rospy.Subscriber('/map', OccupancyGrid, self.callback_map)

    def callback_map(self, map):
        """ DESCRIPTION

            Args:
        """
        try:
            self.talker_automap(map)
            # log input data as debug-level message
            rospy.logdebug(map)
        except rospy.ROSInterruptException:
            pass

    def talker_automap(self, map):
        """ DESCRIPTION

            Args:

            Returns and Publishes:
        """
        # Create an action client called "move_base" with action definition file "MoveBaseAction"
        client = actionlib.SimpleActionClient('move_base', MoveBaseAction)

        # Waits until the action server has started up and started listening for goals.
        client.wait_for_server()

        # Creates a new goal with the MoveBaseGoal constructor
        goal = MoveBaseGoal()
        goal.target_pose.header.frame_id = "map"
        goal.target_pose.header.stamp = rospy.Time.now()
        # Move 0.5 meters forward along the x axis of the "map" coordinate frame
        goal.target_pose.pose.position.x = -1.0
        goal.target_pose.pose.position.y = -1.0
        # No rotation of the mobile base frame w.r.t. map frame
        goal.target_pose.pose.orientation.w = 1.0

        # Sends the goal to the action server.
        client.send_goal(goal)
        # Waits for the server to finish performing the action.
        wait = client.wait_for_result()
        # If the result doesn't arrive, assume the Server is not available
        if not wait:
            rospy.logerr("Action server not available!")
            rospy.signal_shutdown("Action server not available!")
        else:
            # Result of executing the action
            rospy.loginfo(client.get_result())
            return client.get_result()


def main():
    """ The main() function. """
    # Initialise node
    automap = AutoMap()
    rospy.spin()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass